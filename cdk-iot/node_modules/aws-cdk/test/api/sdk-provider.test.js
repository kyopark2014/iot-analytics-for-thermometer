"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const cxapi = require("@aws-cdk/cx-api");
const AWS = require("aws-sdk");
const promptly = require("promptly");
const uuid = require("uuid");
const aws_auth_1 = require("../../lib/api/aws-auth");
const plugin_1 = require("../../lib/api/plugin");
const logging = require("../../lib/logging");
const bockfs = require("../bockfs");
const util_1 = require("../util");
const fake_sts_1 = require("./fake-sts");
jest.mock('promptly', () => ({
    prompt: jest.fn().mockResolvedValue('1234'),
}));
const defaultCredOptions = {
    ec2creds: false,
    containerCreds: false,
};
let uid;
let pluginQueried = false;
beforeEach(() => {
    // Cache busters!
    // We prefix everything with UUIDs because:
    //
    // - We have a cache from account# -> credentials
    // - We have a cache from access key -> account
    uid = `(${uuid.v4()})`;
    logging.setLogLevel(logging.LogLevel.TRACE);
    plugin_1.PluginHost.instance.credentialProviderSources.splice(0);
    plugin_1.PluginHost.instance.credentialProviderSources.push({
        isAvailable() { return Promise.resolve(true); },
        canProvideCredentials(account) { return Promise.resolve(account === uniq('99999')); },
        getProvider() {
            pluginQueried = true;
            return Promise.resolve(new AWS.Credentials({
                accessKeyId: `${uid}plugin_key`,
                secretAccessKey: 'plugin_secret',
                sessionToken: 'plugin_token',
            }));
        },
        name: 'test plugin',
    });
    // Make sure these point to nonexistant files to start, if we don't call
    // prepare() then we don't accidentally want to fall back to system config.
    process.env.AWS_CONFIG_FILE = '/dev/null';
    process.env.AWS_SHARED_CREDENTIALS_FILE = '/dev/null';
});
afterEach(() => {
    bockfs.restore();
});
function uniq(account) {
    return `${uid}${account}`;
}
function env(account) {
    return cxapi.EnvironmentUtils.make(account, 'def');
}
describe('with intercepted network calls', () => {
    // Most tests will use intercepted network calls, except one test that tests
    // that the right HTTP `Agent` is used.
    let fakeSts;
    beforeEach(() => {
        fakeSts = new fake_sts_1.FakeSts();
        fakeSts.begin();
        // Make sure the KeyID returned by the plugin is recognized
        fakeSts.registerUser(uniq('99999'), uniq('plugin_key'));
    });
    afterEach(() => {
        fakeSts.restore();
    });
    // Set of tests where the CDK will not trigger assume-role
    // (the INI file might still do assume-role)
    describe('when CDK does not AssumeRole', () => {
        test('uses default credentials by default', async () => {
            // WHEN
            prepareCreds({
                fakeSts,
                credentials: {
                    default: { aws_access_key_id: 'access', $account: '11111', $fakeStsOptions: { partition: 'aws-here' } },
                },
                config: {
                    default: { region: 'eu-bla-5' },
                },
            });
            const provider = await providerFromProfile(undefined);
            // THEN
            expect(provider.defaultRegion).toEqual('eu-bla-5');
            await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('11111'), partition: 'aws-here' });
            // Ask for a different region
            const sdk = (await provider.forEnvironment({ ...env(uniq('11111')), region: 'rgn' }, aws_auth_1.Mode.ForReading)).sdk;
            expect(sdkConfig(sdk).credentials.accessKeyId).toEqual(uniq('access'));
            expect(sdk.currentRegion).toEqual('rgn');
        });
        test('throws if profile credentials are not for the right account', async () => {
            // WHEN
            prepareCreds({
                fakeSts,
                config: {
                    'profile boo': { aws_access_key_id: 'access', $account: '11111' },
                },
            });
            const provider = await providerFromProfile('boo');
            await expect(provider.forEnvironment(env(uniq('some_account_#')), aws_auth_1.Mode.ForReading)).rejects.toThrow('Need to perform AWS calls');
        });
        test('use profile acct/region if agnostic env requested', async () => {
            // WHEN
            prepareCreds({
                fakeSts,
                credentials: {
                    default: { aws_access_key_id: 'access', $account: '11111' },
                },
                config: {
                    default: { region: 'eu-bla-5' },
                },
            });
            const provider = await providerFromProfile(undefined);
            // THEN
            const sdk = (await provider.forEnvironment(cxapi.EnvironmentUtils.make(cxapi.UNKNOWN_ACCOUNT, cxapi.UNKNOWN_REGION), aws_auth_1.Mode.ForReading)).sdk;
            expect(sdkConfig(sdk).credentials.accessKeyId).toEqual(uniq('access'));
            expect((await sdk.currentAccount()).accountId).toEqual(uniq('11111'));
            expect(sdk.currentRegion).toEqual('eu-bla-5');
        });
        test('passing profile skips EnvironmentCredentials', async () => {
            // GIVEN
            prepareCreds({
                fakeSts,
                credentials: {
                    foo: { aws_access_key_id: 'access', $account: '11111' },
                },
            });
            const provider = await providerFromProfile('foo');
            const environmentCredentialsPrototype = (new AWS.EnvironmentCredentials('AWS')).constructor.prototype;
            await util_1.withMocked(environmentCredentialsPrototype, 'refresh', async (refresh) => {
                var _a;
                refresh.mockImplementation((callback) => callback(new Error('This function should not have been called')));
                // WHEN
                expect((_a = (await provider.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId).toEqual(uniq('11111'));
                expect(refresh).not.toHaveBeenCalled();
            });
        });
        test('supports profile spread over config_file and credentials_file', async () => {
            // WHEN
            prepareCreds({
                fakeSts,
                credentials: {
                    foo: { aws_access_key_id: 'fooccess', $account: '22222' },
                },
                config: {
                    'default': { region: 'eu-bla-5' },
                    'profile foo': { region: 'eu-west-1' },
                },
            });
            const provider = await aws_auth_1.SdkProvider.withAwsCliCompatibleDefaults({ ...defaultCredOptions, profile: 'foo' });
            // THEN
            expect(provider.defaultRegion).toEqual('eu-west-1');
            await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('22222'), partition: 'aws' });
            const sdk = (await provider.forEnvironment(env(uniq('22222')), aws_auth_1.Mode.ForReading)).sdk;
            expect(sdkConfig(sdk).credentials.accessKeyId).toEqual(uniq('fooccess'));
        });
        test('supports profile only in config_file', async () => {
            // WHEN
            prepareCreds({
                fakeSts,
                config: {
                    'default': { region: 'eu-bla-5' },
                    'profile foo': { aws_access_key_id: 'fooccess', $account: '22222' },
                },
            });
            const provider = await providerFromProfile('foo');
            // THEN
            expect(provider.defaultRegion).toEqual('eu-bla-5'); // Fall back to default config
            await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('22222'), partition: 'aws' });
            const sdk = (await provider.forEnvironment(env(uniq('22222')), aws_auth_1.Mode.ForReading)).sdk;
            expect(sdkConfig(sdk).credentials.accessKeyId).toEqual(uniq('fooccess'));
        });
        test('can assume-role configured in config', async () => {
            // GIVEN
            prepareCreds({
                fakeSts,
                credentials: {
                    assumer: { aws_access_key_id: 'assumer', $account: '11111' },
                },
                config: {
                    'default': { region: 'eu-bla-5' },
                    'profile assumer': { region: 'us-east-2' },
                    'profile assumable': {
                        role_arn: 'arn:aws:iam::66666:role/Assumable',
                        source_profile: 'assumer',
                        $account: '66666',
                        $fakeStsOptions: { allowedAccounts: ['11111'] },
                    },
                },
            });
            const provider = await providerFromProfile('assumable');
            // WHEN
            const sdk = (await provider.forEnvironment(env(uniq('66666')), aws_auth_1.Mode.ForReading)).sdk;
            // THEN
            expect((await sdk.currentAccount()).accountId).toEqual(uniq('66666'));
        });
        test('can assume role even if [default] profile is missing', async () => {
            var _a;
            // GIVEN
            prepareCreds({
                fakeSts,
                credentials: {
                    assumer: { aws_access_key_id: 'assumer', $account: '22222' },
                    assumable: { role_arn: 'arn:aws:iam::12356789012:role/Assumable', source_profile: 'assumer', $account: '22222' },
                },
                config: {
                    'profile assumable': { region: 'eu-bla-5' },
                },
            });
            // WHEN
            const provider = await providerFromProfile('assumable');
            // THEN
            expect((_a = (await provider.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId).toEqual(uniq('22222'));
        });
        test('mfa_serial in profile will ask user for token', async () => {
            // GIVEN
            prepareCreds({
                fakeSts,
                credentials: {
                    assumer: { aws_access_key_id: 'assumer', $account: '66666' },
                },
                config: {
                    'default': { region: 'eu-bla-5' },
                    'profile assumer': { region: 'us-east-2' },
                    'profile mfa-role': {
                        role_arn: 'arn:aws:iam::66666:role/Assumable',
                        source_profile: 'assumer',
                        mfa_serial: 'arn:aws:iam::account:mfa/user',
                        $account: '66666',
                    },
                },
            });
            const provider = await providerFromProfile('mfa-role');
            const promptlyMockCalls = promptly.prompt.mock.calls.length;
            // THEN
            const sdk = (await provider.forEnvironment(env(uniq('66666')), aws_auth_1.Mode.ForReading)).sdk;
            expect((await sdk.currentAccount()).accountId).toEqual(uniq('66666'));
            expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({
                roleArn: 'arn:aws:iam::66666:role/Assumable',
                serialNumber: 'arn:aws:iam::account:mfa/user',
                tokenCode: '1234',
            }));
            // Mock response was set to fail to make sure we don't call STS
            // Make sure the MFA mock was called during this test
            expect(promptly.prompt.mock.calls.length).toBe(promptlyMockCalls + 1);
        });
    });
    // For DefaultSynthesis we will do an assume-role after having gotten base credentials
    describe('when CDK AssumeRoles', () => {
        beforeEach(() => {
            // All these tests share that 'arn:aws:role' is a role into account 88888 which can be assumed from 11111
            fakeSts.registerRole(uniq('88888'), 'arn:aws:role', { allowedAccounts: [uniq('11111')] });
        });
        test('error we get from assuming a role is useful', async () => {
            // GIVEN
            prepareCreds({
                fakeSts,
                config: {
                    default: { aws_access_key_id: 'foo' },
                },
            });
            const provider = await providerFromProfile(undefined);
            // WHEN
            const promise = provider.forEnvironment(env(uniq('88888')), aws_auth_1.Mode.ForReading, {
                assumeRoleArn: 'doesnotexist.role.arn',
            });
            // THEN - error message contains both a helpful hint and the underlying AssumeRole message
            await expect(promise).rejects.toThrow('(re)-bootstrap the environment');
            await expect(promise).rejects.toThrow('doesnotexist.role.arn');
        });
        test('assuming a role sanitizes the username into the session name', async () => {
            // GIVEN
            prepareCreds({
                fakeSts,
                config: {
                    default: { aws_access_key_id: 'foo', $account: '11111' },
                },
            });
            await util_1.withMocked(os, 'userInfo', async (userInfo) => {
                userInfo.mockReturnValue({ username: 'skÃ¥l', uid: 1, gid: 1, homedir: '/here', shell: '/bin/sh' });
                // WHEN
                const provider = await providerFromProfile(undefined);
                const sdk = (await provider.forEnvironment(env(uniq('88888')), aws_auth_1.Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk;
                await sdk.currentAccount();
                // THEN
                expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({
                    roleSessionName: 'aws-cdk-sk@l',
                }));
            });
        });
        test('even if current credentials are for the wrong account, we will still use them to AssumeRole', async () => {
            // GIVEN
            prepareCreds({
                fakeSts,
                config: {
                    default: { aws_access_key_id: 'foo', $account: '11111' },
                },
            });
            const provider = await providerFromProfile(undefined);
            // WHEN
            const sdk = (await provider.forEnvironment(env(uniq('88888')), aws_auth_1.Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk;
            // THEN
            expect((await sdk.currentAccount()).accountId).toEqual(uniq('88888'));
        });
        test('if AssumeRole fails but current credentials are for the right account, we will still use them', async () => {
            // GIVEN
            prepareCreds({
                fakeSts,
                config: {
                    default: { aws_access_key_id: 'foo', $account: '88888' },
                },
            });
            const provider = await providerFromProfile(undefined);
            // WHEN - assumeRole fails because the role can only be assumed from account 11111
            const sdk = (await provider.forEnvironment(env(uniq('88888')), aws_auth_1.Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk;
            // THEN
            expect((await sdk.currentAccount()).accountId).toEqual(uniq('88888'));
        });
    });
    describe('Plugins', () => {
        test('does not use plugins if current credentials are for expected account', async () => {
            prepareCreds({
                fakeSts,
                config: {
                    default: { aws_access_key_id: 'foo', $account: '11111' },
                },
            });
            const provider = await providerFromProfile(undefined);
            await provider.forEnvironment(env(uniq('11111')), aws_auth_1.Mode.ForReading);
            expect(pluginQueried).toEqual(false);
        });
        test('uses plugin for account 99999', async () => {
            const provider = await providerFromProfile(undefined);
            await provider.forEnvironment(env(uniq('99999')), aws_auth_1.Mode.ForReading);
            expect(pluginQueried).toEqual(true);
        });
        test('can assume role with credentials from plugin', async () => {
            fakeSts.registerRole(uniq('99999'), 'arn:aws:iam::99999:role/Assumable');
            const provider = await providerFromProfile(undefined);
            await provider.forEnvironment(env(uniq('99999')), aws_auth_1.Mode.ForReading, {
                assumeRoleArn: 'arn:aws:iam::99999:role/Assumable',
            });
            expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({
                roleArn: 'arn:aws:iam::99999:role/Assumable',
            }));
            expect(pluginQueried).toEqual(true);
        });
        test('even if AssumeRole fails but current credentials are from a plugin, we will still use them', async () => {
            const provider = await providerFromProfile(undefined);
            const sdk = (await provider.forEnvironment(env(uniq('99999')), aws_auth_1.Mode.ForReading, { assumeRoleArn: 'does:not:exist' })).sdk;
            // THEN
            expect((await sdk.currentAccount()).accountId).toEqual(uniq('99999'));
        });
        test('plugins are still queried even if current credentials are expired (or otherwise invalid)', async () => {
            // GIVEN
            process.env.AWS_ACCESS_KEY_ID = `${uid}akid`;
            process.env.AWS_SECRET_ACCESS_KEY = 'sekrit';
            const provider = await providerFromProfile(undefined);
            // WHEN
            await provider.forEnvironment(env(uniq('99999')), aws_auth_1.Mode.ForReading);
            // THEN
            expect(pluginQueried).toEqual(true);
        });
    });
    describe('support for credential_source', () => {
        test('can assume role with ecs credentials', async () => {
            return util_1.withMocked(AWS.ECSCredentials.prototype, 'needsRefresh', async (needsRefresh) => {
                // GIVEN
                prepareCreds({
                    config: {
                        'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'EcsContainer', $account: '22222' },
                    },
                });
                const provider = await providerFromProfile('ecs');
                // WHEN
                await provider.defaultAccount();
                // THEN
                expect(needsRefresh).toHaveBeenCalled();
            });
        });
        test('can assume role with ec2 credentials', async () => {
            return util_1.withMocked(AWS.EC2MetadataCredentials.prototype, 'needsRefresh', async (needsRefresh) => {
                // GIVEN
                prepareCreds({
                    config: {
                        'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'Ec2InstanceMetadata', $account: '22222' },
                    },
                });
                const provider = await providerFromProfile('ecs');
                // WHEN
                await provider.defaultAccount();
                // THEN
                expect(needsRefresh).toHaveBeenCalled();
            });
        });
        test('can assume role with env credentials', async () => {
            return util_1.withMocked(AWS.EnvironmentCredentials.prototype, 'needsRefresh', async (needsRefresh) => {
                // GIVEN
                prepareCreds({
                    config: {
                        'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'Environment', $account: '22222' },
                    },
                });
                const provider = await providerFromProfile('ecs');
                // WHEN
                await provider.defaultAccount();
                // THEN
                expect(needsRefresh).toHaveBeenCalled();
            });
        });
        test('assume fails with unsupported credential_source', async () => {
            // GIVEN
            prepareCreds({
                config: {
                    'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'unsupported', $account: '22222' },
                },
            });
            const provider = await providerFromProfile('ecs');
            // WHEN
            const account = await provider.defaultAccount();
            // THEN
            expect(account === null || account === void 0 ? void 0 : account.accountId).toEqual(undefined);
        });
    });
    test('defaultAccount returns undefined if STS call fails', async () => {
        // GIVEN
        process.env.AWS_ACCESS_KEY_ID = `${uid}akid`;
        process.env.AWS_SECRET_ACCESS_KEY = 'sekrit';
        // WHEN
        const provider = await providerFromProfile(undefined);
        // THEN
        await expect(provider.defaultAccount()).resolves.toBe(undefined);
    });
});
test('even when using a profile to assume another profile, STS calls goes through the proxy', async () => {
    prepareCreds({
        credentials: {
            assumer: { aws_access_key_id: 'assumer' },
        },
        config: {
            'default': { region: 'eu-bla-5' },
            'profile assumable': { role_arn: 'arn:aws:iam::66666:role/Assumable', source_profile: 'assumer', $account: '66666' },
            'profile assumer': { region: 'us-east-2' },
        },
    });
    // Messy mocking
    let called = false;
    jest.mock('proxy-agent', () => {
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        class FakeAgent extends require('https').Agent {
            addRequest(_, __) {
                // FIXME: this error takes 6 seconds to be completely handled. It
                // might be retries in the SDK somewhere, or something about the Node
                // event loop. I've spent an hour trying to figure it out and I can't,
                // and I gave up. We'll just have to live with this until someone gets
                // inspired.
                const error = new Error('ABORTED BY TEST');
                error.code = 'RequestAbortedError';
                error.retryable = false;
                called = true;
                throw error;
            }
        }
        return FakeAgent;
    });
    // WHEN
    const provider = await aws_auth_1.SdkProvider.withAwsCliCompatibleDefaults({
        ...defaultCredOptions,
        profile: 'assumable',
        httpOptions: {
            proxyAddress: 'http://DOESNTMATTER/',
        },
    });
    await provider.defaultAccount();
    // THEN -- the fake proxy agent got called, we don't care about the result
    expect(called).toEqual(true);
});
/**
 * Use object hackery to get the credentials out of the SDK object
 */
function sdkConfig(sdk) {
    return sdk.config;
}
/**
 * Fixture for SDK auth for this test suite
 *
 * Has knowledge of the cache buster, will write proper fake config files and
 * register users and roles in FakeSts at the same time.
 */
function prepareCreds(options) {
    function convertSections(sections) {
        var _a, _b, _c, _d, _e, _f;
        const ret = [];
        for (const [profile, user] of Object.entries(sections !== null && sections !== void 0 ? sections : {})) {
            ret.push(`[${profile}]`);
            if (isProfileRole(user)) {
                ret.push(`role_arn=${user.role_arn}`);
                if ('source_profile' in user) {
                    ret.push(`source_profile=${user.source_profile}`);
                }
                if ('credential_source' in user) {
                    ret.push(`credential_source=${user.credential_source}`);
                }
                if (user.mfa_serial) {
                    ret.push(`mfa_serial=${user.mfa_serial}`);
                }
                (_a = options.fakeSts) === null || _a === void 0 ? void 0 : _a.registerRole(uniq((_b = user.$account) !== null && _b !== void 0 ? _b : '00000'), user.role_arn, {
                    ...user.$fakeStsOptions,
                    allowedAccounts: (_d = (_c = user.$fakeStsOptions) === null || _c === void 0 ? void 0 : _c.allowedAccounts) === null || _d === void 0 ? void 0 : _d.map(uniq),
                });
            }
            else {
                if (user.aws_access_key_id) {
                    ret.push(`aws_access_key_id=${uniq(user.aws_access_key_id)}`);
                    ret.push('aws_secret_access_key=secret');
                    (_e = options.fakeSts) === null || _e === void 0 ? void 0 : _e.registerUser(uniq((_f = user.$account) !== null && _f !== void 0 ? _f : '00000'), uniq(user.aws_access_key_id), user.$fakeStsOptions);
                }
            }
            if (user.region) {
                ret.push(`region=${user.region}`);
            }
        }
        return ret.join('\n');
    }
    bockfs({
        '/home/me/.bxt/credentials': convertSections(options.credentials),
        '/home/me/.bxt/config': convertSections(options.config),
    });
    // Set environment variables that we want
    process.env.AWS_CONFIG_FILE = bockfs.path('/home/me/.bxt/config');
    process.env.AWS_SHARED_CREDENTIALS_FILE = bockfs.path('/home/me/.bxt/credentials');
}
function isProfileRole(x) {
    return 'role_arn' in x;
}
function providerFromProfile(profile) {
    return aws_auth_1.SdkProvider.withAwsCliCompatibleDefaults({ ...defaultCredOptions, profile });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLXByb3ZpZGVyLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzZGstcHJvdmlkZXIudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlCQUF5QjtBQUN6Qix5Q0FBeUM7QUFDekMsK0JBQStCO0FBRS9CLHFDQUFxQztBQUNyQyw2QkFBNkI7QUFDN0IscURBQXNFO0FBQ3RFLGlEQUFrRDtBQUNsRCw2Q0FBNkM7QUFDN0Msb0NBQW9DO0FBQ3BDLGtDQUFxQztBQUNyQyx5Q0FBK0U7QUFFL0UsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUMzQixNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQztDQUM1QyxDQUFDLENBQUMsQ0FBQztBQUVKLE1BQU0sa0JBQWtCLEdBQUc7SUFDekIsUUFBUSxFQUFFLEtBQUs7SUFDZixjQUFjLEVBQUUsS0FBSztDQUN0QixDQUFDO0FBRUYsSUFBSSxHQUFXLENBQUM7QUFDaEIsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDO0FBRTFCLFVBQVUsQ0FBQyxHQUFHLEVBQUU7SUFDZCxpQkFBaUI7SUFDakIsMkNBQTJDO0lBQzNDLEVBQUU7SUFDRixpREFBaUQ7SUFDakQsK0NBQStDO0lBQy9DLEdBQUcsR0FBRyxJQUFJLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDO0lBRXZCLE9BQU8sQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU1QyxtQkFBVSxDQUFDLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEQsbUJBQVUsQ0FBQyxRQUFRLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDO1FBQ2pELFdBQVcsS0FBSyxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxD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QztBQUN6QixDQUFDO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxPQUEyQjtJQUN0RCxPQUFPLHNCQUFXLENBQUMsNEJBQTRCLENBQUMsRUFBRSxHQUFHLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7QUFDdEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgdHlwZSB7IENvbmZpZ3VyYXRpb25PcHRpb25zIH0gZnJvbSAnYXdzLXNkay9saWIvY29uZmlnLWJhc2UnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0ICogYXMgdXVpZCBmcm9tICd1dWlkJztcbmltcG9ydCB7IElTREssIE1vZGUsIFNESywgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi8uLi9saWIvYXBpL2F3cy1hdXRoJztcbmltcG9ydCB7IFBsdWdpbkhvc3QgfSBmcm9tICcuLi8uLi9saWIvYXBpL3BsdWdpbic7XG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gJy4uLy4uL2xpYi9sb2dnaW5nJztcbmltcG9ydCAqIGFzIGJvY2tmcyBmcm9tICcuLi9ib2NrZnMnO1xuaW1wb3J0IHsgd2l0aE1vY2tlZCB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgRmFrZVN0cywgUmVnaXN0ZXJSb2xlT3B0aW9ucywgUmVnaXN0ZXJVc2VyT3B0aW9ucyB9IGZyb20gJy4vZmFrZS1zdHMnO1xuXG5qZXN0Lm1vY2soJ3Byb21wdGx5JywgKCkgPT4gKHtcbiAgcHJvbXB0OiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoJzEyMzQnKSxcbn0pKTtcblxuY29uc3QgZGVmYXVsdENyZWRPcHRpb25zID0ge1xuICBlYzJjcmVkczogZmFsc2UsXG4gIGNvbnRhaW5lckNyZWRzOiBmYWxzZSxcbn07XG5cbmxldCB1aWQ6IHN0cmluZztcbmxldCBwbHVnaW5RdWVyaWVkID0gZmFsc2U7XG5cbmJlZm9yZUVhY2goKCkgPT4ge1xuICAvLyBDYWNoZSBidXN0ZXJzIVxuICAvLyBXZSBwcmVmaXggZXZlcnl0aGluZyB3aXRoIFVVSURzIGJlY2F1c2U6XG4gIC8vXG4gIC8vIC0gV2UgaGF2ZSBhIGNhY2hlIGZyb20gYWNjb3VudCMgLT4gY3JlZGVudGlhbHNcbiAgLy8gLSBXZSBoYXZlIGEgY2FjaGUgZnJvbSBhY2Nlc3Mga2V5IC0+IGFjY291bnRcbiAgdWlkID0gYCgke3V1aWQudjQoKX0pYDtcblxuICBsb2dnaW5nLnNldExvZ0xldmVsKGxvZ2dpbmcuTG9nTGV2ZWwuVFJBQ0UpO1xuXG4gIFBsdWdpbkhvc3QuaW5zdGFuY2UuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy5zcGxpY2UoMCk7XG4gIFBsdWdpbkhvc3QuaW5zdGFuY2UuY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy5wdXNoKHtcbiAgICBpc0F2YWlsYWJsZSgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTsgfSxcbiAgICBjYW5Qcm92aWRlQ3JlZGVudGlhbHMoYWNjb3VudCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFjY291bnQgPT09IHVuaXEoJzk5OTk5JykpOyB9LFxuICAgIGdldFByb3ZpZGVyKCkge1xuICAgICAgcGx1Z2luUXVlcmllZCA9IHRydWU7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBV1MuQ3JlZGVudGlhbHMoe1xuICAgICAgICBhY2Nlc3NLZXlJZDogYCR7dWlkfXBsdWdpbl9rZXlgLFxuICAgICAgICBzZWNyZXRBY2Nlc3NLZXk6ICdwbHVnaW5fc2VjcmV0JyxcbiAgICAgICAgc2Vzc2lvblRva2VuOiAncGx1Z2luX3Rva2VuJyxcbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIG5hbWU6ICd0ZXN0IHBsdWdpbicsXG4gIH0pO1xuXG4gIC8vIE1ha2Ugc3VyZSB0aGVzZSBwb2ludCB0byBub25leGlzdGFudCBmaWxlcyB0byBzdGFydCwgaWYgd2UgZG9uJ3QgY2FsbFxuICAvLyBwcmVwYXJlKCkgdGhlbiB3ZSBkb24ndCBhY2NpZGVudGFsbHkgd2FudCB0byBmYWxsIGJhY2sgdG8gc3lzdGVtIGNvbmZpZy5cbiAgcHJvY2Vzcy5lbnYuQVdTX0NPTkZJR19GSUxFID0gJy9kZXYvbnVsbCc7XG4gIHByb2Nlc3MuZW52LkFXU19TSEFSRURfQ1JFREVOVElBTFNfRklMRSA9ICcvZGV2L251bGwnO1xufSk7XG5cbmFmdGVyRWFjaCgoKSA9PiB7XG4gIGJvY2tmcy5yZXN0b3JlKCk7XG59KTtcblxuZnVuY3Rpb24gdW5pcShhY2NvdW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGAke3VpZH0ke2FjY291bnR9YDtcbn1cblxuZnVuY3Rpb24gZW52KGFjY291bnQ6IHN0cmluZykge1xuICByZXR1cm4gY3hhcGkuRW52aXJvbm1lbnRVdGlscy5tYWtlKGFjY291bnQsICdkZWYnKTtcbn1cblxuZGVzY3JpYmUoJ3dpdGggaW50ZXJjZXB0ZWQgbmV0d29yayBjYWxscycsICgpID0+IHtcbiAgLy8gTW9zdCB0ZXN0cyB3aWxsIHVzZSBpbnRlcmNlcHRlZCBuZXR3b3JrIGNhbGxzLCBleGNlcHQgb25lIHRlc3QgdGhhdCB0ZXN0c1xuICAvLyB0aGF0IHRoZSByaWdodCBIVFRQIGBBZ2VudGAgaXMgdXNlZC5cblxuICBsZXQgZmFrZVN0czogRmFrZVN0cztcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgZmFrZVN0cyA9IG5ldyBGYWtlU3RzKCk7XG4gICAgZmFrZVN0cy5iZWdpbigpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBLZXlJRCByZXR1cm5lZCBieSB0aGUgcGx1Z2luIGlzIHJlY29nbml6ZWRcbiAgICBmYWtlU3RzLnJlZ2lzdGVyVXNlcih1bmlxKCc5OTk5OScpLCB1bmlxKCdwbHVnaW5fa2V5JykpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGZha2VTdHMucmVzdG9yZSgpO1xuICB9KTtcblxuICAvLyBTZXQgb2YgdGVzdHMgd2hlcmUgdGhlIENESyB3aWxsIG5vdCB0cmlnZ2VyIGFzc3VtZS1yb2xlXG4gIC8vICh0aGUgSU5JIGZpbGUgbWlnaHQgc3RpbGwgZG8gYXNzdW1lLXJvbGUpXG4gIGRlc2NyaWJlKCd3aGVuIENESyBkb2VzIG5vdCBBc3N1bWVSb2xlJywgKCkgPT4ge1xuICAgIHRlc3QoJ3VzZXMgZGVmYXVsdCBjcmVkZW50aWFscyBieSBkZWZhdWx0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gV0hFTlxuICAgICAgcHJlcGFyZUNyZWRzKHtcbiAgICAgICAgZmFrZVN0cyxcbiAgICAgICAgY3JlZGVudGlhbHM6IHtcbiAgICAgICAgICBkZWZhdWx0OiB7IGF3c19hY2Nlc3Nfa2V5X2lkOiAnYWNjZXNzJywgJGFjY291bnQ6ICcxMTExMScsICRmYWtlU3RzT3B0aW9uczogeyBwYXJ0aXRpb246ICdhd3MtaGVyZScgfSB9LFxuICAgICAgICB9LFxuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICBkZWZhdWx0OiB7IHJlZ2lvbjogJ2V1LWJsYS01JyB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUodW5kZWZpbmVkKTtcblxuICAgICAgLy8gVEhFTlxuICAgICAgZXhwZWN0KHByb3ZpZGVyLmRlZmF1bHRSZWdpb24pLnRvRXF1YWwoJ2V1LWJsYS01Jyk7XG4gICAgICBhd2FpdCBleHBlY3QocHJvdmlkZXIuZGVmYXVsdEFjY291bnQoKSkucmVzb2x2ZXMudG9FcXVhbCh7IGFjY291bnRJZDogdW5pcSgnMTExMTEnKSwgcGFydGl0aW9uOiAnYXdzLWhlcmUnIH0pO1xuXG4gICAgICAvLyBBc2sgZm9yIGEgZGlmZmVyZW50IHJlZ2lvblxuICAgICAgY29uc3Qgc2RrID0gKGF3YWl0IHByb3ZpZGVyLmZvckVudmlyb25tZW50KHsgLi4uZW52KHVuaXEoJzExMTExJykpLCByZWdpb246ICdyZ24nIH0sIE1vZGUuRm9yUmVhZGluZykpLnNkaztcbiAgICAgIGV4cGVjdChzZGtDb25maWcoc2RrKS5jcmVkZW50aWFscyEuYWNjZXNzS2V5SWQpLnRvRXF1YWwodW5pcSgnYWNjZXNzJykpO1xuICAgICAgZXhwZWN0KHNkay5jdXJyZW50UmVnaW9uKS50b0VxdWFsKCdyZ24nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Rocm93cyBpZiBwcm9maWxlIGNyZWRlbnRpYWxzIGFyZSBub3QgZm9yIHRoZSByaWdodCBhY2NvdW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gV0hFTlxuICAgICAgcHJlcGFyZUNyZWRzKHtcbiAgICAgICAgZmFrZVN0cyxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgJ3Byb2ZpbGUgYm9vJzogeyBhd3NfYWNjZXNzX2tleV9pZDogJ2FjY2VzcycsICRhY2NvdW50OiAnMTExMTEnIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgcHJvdmlkZXJGcm9tUHJvZmlsZSgnYm9vJyk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChwcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnYodW5pcSgnc29tZV9hY2NvdW50XyMnKSksIE1vZGUuRm9yUmVhZGluZykpLnJlamVjdHMudG9UaHJvdygnTmVlZCB0byBwZXJmb3JtIEFXUyBjYWxscycpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgndXNlIHByb2ZpbGUgYWNjdC9yZWdpb24gaWYgYWdub3N0aWMgZW52IHJlcXVlc3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFdIRU5cbiAgICAgIHByZXBhcmVDcmVkcyh7XG4gICAgICAgIGZha2VTdHMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgZGVmYXVsdDogeyBhd3NfYWNjZXNzX2tleV9pZDogJ2FjY2VzcycsICRhY2NvdW50OiAnMTExMTEnIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIGRlZmF1bHQ6IHsgcmVnaW9uOiAnZXUtYmxhLTUnIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgcHJvdmlkZXJGcm9tUHJvZmlsZSh1bmRlZmluZWQpO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBjb25zdCBzZGsgPSAoYXdhaXQgcHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoY3hhcGkuRW52aXJvbm1lbnRVdGlscy5tYWtlKGN4YXBpLlVOS05PV05fQUNDT1VOVCwgY3hhcGkuVU5LTk9XTl9SRUdJT04pLCBNb2RlLkZvclJlYWRpbmcpKS5zZGs7XG4gICAgICBleHBlY3Qoc2RrQ29uZmlnKHNkaykuY3JlZGVudGlhbHMhLmFjY2Vzc0tleUlkKS50b0VxdWFsKHVuaXEoJ2FjY2VzcycpKTtcbiAgICAgIGV4cGVjdCgoYXdhaXQgc2RrLmN1cnJlbnRBY2NvdW50KCkpLmFjY291bnRJZCkudG9FcXVhbCh1bmlxKCcxMTExMScpKTtcbiAgICAgIGV4cGVjdChzZGsuY3VycmVudFJlZ2lvbikudG9FcXVhbCgnZXUtYmxhLTUnKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3Bhc3NpbmcgcHJvZmlsZSBza2lwcyBFbnZpcm9ubWVudENyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIHByZXBhcmVDcmVkcyh7XG4gICAgICAgIGZha2VTdHMsXG4gICAgICAgIGNyZWRlbnRpYWxzOiB7XG4gICAgICAgICAgZm9vOiB7IGF3c19hY2Nlc3Nfa2V5X2lkOiAnYWNjZXNzJywgJGFjY291bnQ6ICcxMTExMScgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBwcm92aWRlckZyb21Qcm9maWxlKCdmb28nKTtcblxuICAgICAgY29uc3QgZW52aXJvbm1lbnRDcmVkZW50aWFsc1Byb3RvdHlwZSA9IChuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpKS5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICAgIGF3YWl0IHdpdGhNb2NrZWQoZW52aXJvbm1lbnRDcmVkZW50aWFsc1Byb3RvdHlwZSwgJ3JlZnJlc2gnLCBhc3luYyAocmVmcmVzaCkgPT4ge1xuICAgICAgICByZWZyZXNoLm1vY2tJbXBsZW1lbnRhdGlvbigoY2FsbGJhY2s6IChlcnI/OiBFcnJvcikgPT4gdm9pZCkgPT4gY2FsbGJhY2sobmV3IEVycm9yKCdUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgaGF2ZSBiZWVuIGNhbGxlZCcpKSk7XG5cbiAgICAgICAgLy8gV0hFTlxuICAgICAgICBleHBlY3QoKGF3YWl0IHByb3ZpZGVyLmRlZmF1bHRBY2NvdW50KCkpPy5hY2NvdW50SWQpLnRvRXF1YWwodW5pcSgnMTExMTEnKSk7XG5cbiAgICAgICAgZXhwZWN0KHJlZnJlc2gpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3N1cHBvcnRzIHByb2ZpbGUgc3ByZWFkIG92ZXIgY29uZmlnX2ZpbGUgYW5kIGNyZWRlbnRpYWxzX2ZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBXSEVOXG4gICAgICBwcmVwYXJlQ3JlZHMoe1xuICAgICAgICBmYWtlU3RzLFxuICAgICAgICBjcmVkZW50aWFsczoge1xuICAgICAgICAgIGZvbzogeyBhd3NfYWNjZXNzX2tleV9pZDogJ2Zvb2NjZXNzJywgJGFjY291bnQ6ICcyMjIyMicgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgJ2RlZmF1bHQnOiB7IHJlZ2lvbjogJ2V1LWJsYS01JyB9LFxuICAgICAgICAgICdwcm9maWxlIGZvbyc6IHsgcmVnaW9uOiAnZXUtd2VzdC0xJyB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IFNka1Byb3ZpZGVyLndpdGhBd3NDbGlDb21wYXRpYmxlRGVmYXVsdHMoeyAuLi5kZWZhdWx0Q3JlZE9wdGlvbnMsIHByb2ZpbGU6ICdmb28nIH0pO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3QocHJvdmlkZXIuZGVmYXVsdFJlZ2lvbikudG9FcXVhbCgnZXUtd2VzdC0xJyk7XG4gICAgICBhd2FpdCBleHBlY3QocHJvdmlkZXIuZGVmYXVsdEFjY291bnQoKSkucmVzb2x2ZXMudG9FcXVhbCh7IGFjY291bnRJZDogdW5pcSgnMjIyMjInKSwgcGFydGl0aW9uOiAnYXdzJyB9KTtcblxuICAgICAgY29uc3Qgc2RrID0gKGF3YWl0IHByb3ZpZGVyLmZvckVudmlyb25tZW50KGVudih1bmlxKCcyMjIyMicpKSwgTW9kZS5Gb3JSZWFkaW5nKSkuc2RrO1xuICAgICAgZXhwZWN0KHNka0NvbmZpZyhzZGspLmNyZWRlbnRpYWxzIS5hY2Nlc3NLZXlJZCkudG9FcXVhbCh1bmlxKCdmb29jY2VzcycpKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3N1cHBvcnRzIHByb2ZpbGUgb25seSBpbiBjb25maWdfZmlsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFdIRU5cbiAgICAgIHByZXBhcmVDcmVkcyh7XG4gICAgICAgIGZha2VTdHMsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICdkZWZhdWx0JzogeyByZWdpb246ICdldS1ibGEtNScgfSxcbiAgICAgICAgICAncHJvZmlsZSBmb28nOiB7IGF3c19hY2Nlc3Nfa2V5X2lkOiAnZm9vY2Nlc3MnLCAkYWNjb3VudDogJzIyMjIyJyB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUoJ2ZvbycpO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3QocHJvdmlkZXIuZGVmYXVsdFJlZ2lvbikudG9FcXVhbCgnZXUtYmxhLTUnKTsgLy8gRmFsbCBiYWNrIHRvIGRlZmF1bHQgY29uZmlnXG4gICAgICBhd2FpdCBleHBlY3QocHJvdmlkZXIuZGVmYXVsdEFjY291bnQoKSkucmVzb2x2ZXMudG9FcXVhbCh7IGFjY291bnRJZDogdW5pcSgnMjIyMjInKSwgcGFydGl0aW9uOiAnYXdzJyB9KTtcblxuICAgICAgY29uc3Qgc2RrID0gKGF3YWl0IHByb3ZpZGVyLmZvckVudmlyb25tZW50KGVudih1bmlxKCcyMjIyMicpKSwgTW9kZS5Gb3JSZWFkaW5nKSkuc2RrO1xuICAgICAgZXhwZWN0KHNka0NvbmZpZyhzZGspLmNyZWRlbnRpYWxzIS5hY2Nlc3NLZXlJZCkudG9FcXVhbCh1bmlxKCdmb29jY2VzcycpKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2NhbiBhc3N1bWUtcm9sZSBjb25maWd1cmVkIGluIGNvbmZpZycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBwcmVwYXJlQ3JlZHMoe1xuICAgICAgICBmYWtlU3RzLFxuICAgICAgICBjcmVkZW50aWFsczoge1xuICAgICAgICAgIGFzc3VtZXI6IHsgYXdzX2FjY2Vzc19rZXlfaWQ6ICdhc3N1bWVyJywgJGFjY291bnQ6ICcxMTExMScgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgJ2RlZmF1bHQnOiB7IHJlZ2lvbjogJ2V1LWJsYS01JyB9LFxuICAgICAgICAgICdwcm9maWxlIGFzc3VtZXInOiB7IHJlZ2lvbjogJ3VzLWVhc3QtMicgfSxcbiAgICAgICAgICAncHJvZmlsZSBhc3N1bWFibGUnOiB7XG4gICAgICAgICAgICByb2xlX2FybjogJ2Fybjphd3M6aWFtOjo2NjY2Njpyb2xlL0Fzc3VtYWJsZScsXG4gICAgICAgICAgICBzb3VyY2VfcHJvZmlsZTogJ2Fzc3VtZXInLFxuICAgICAgICAgICAgJGFjY291bnQ6ICc2NjY2NicsXG4gICAgICAgICAgICAkZmFrZVN0c09wdGlvbnM6IHsgYWxsb3dlZEFjY291bnRzOiBbJzExMTExJ10gfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUoJ2Fzc3VtYWJsZScpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBzZGsgPSAoYXdhaXQgcHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoZW52KHVuaXEoJzY2NjY2JykpLCBNb2RlLkZvclJlYWRpbmcpKS5zZGs7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdCgoYXdhaXQgc2RrLmN1cnJlbnRBY2NvdW50KCkpLmFjY291bnRJZCkudG9FcXVhbCh1bmlxKCc2NjY2NicpKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2NhbiBhc3N1bWUgcm9sZSBldmVuIGlmIFtkZWZhdWx0XSBwcm9maWxlIGlzIG1pc3NpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgcHJlcGFyZUNyZWRzKHtcbiAgICAgICAgZmFrZVN0cyxcbiAgICAgICAgY3JlZGVudGlhbHM6IHtcbiAgICAgICAgICBhc3N1bWVyOiB7IGF3c19hY2Nlc3Nfa2V5X2lkOiAnYXNzdW1lcicsICRhY2NvdW50OiAnMjIyMjInIH0sXG4gICAgICAgICAgYXNzdW1hYmxlOiB7IHJvbGVfYXJuOiAnYXJuOmF3czppYW06OjEyMzU2Nzg5MDEyOnJvbGUvQXNzdW1hYmxlJywgc291cmNlX3Byb2ZpbGU6ICdhc3N1bWVyJywgJGFjY291bnQ6ICcyMjIyMicgfSxcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgJ3Byb2ZpbGUgYXNzdW1hYmxlJzogeyByZWdpb246ICdldS1ibGEtNScgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUoJ2Fzc3VtYWJsZScpO1xuXG4gICAgICAvLyBUSEVOXG4gICAgICBleHBlY3QoKGF3YWl0IHByb3ZpZGVyLmRlZmF1bHRBY2NvdW50KCkpPy5hY2NvdW50SWQpLnRvRXF1YWwodW5pcSgnMjIyMjInKSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdtZmFfc2VyaWFsIGluIHByb2ZpbGUgd2lsbCBhc2sgdXNlciBmb3IgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgcHJlcGFyZUNyZWRzKHtcbiAgICAgICAgZmFrZVN0cyxcbiAgICAgICAgY3JlZGVudGlhbHM6IHtcbiAgICAgICAgICBhc3N1bWVyOiB7IGF3c19hY2Nlc3Nfa2V5X2lkOiAnYXNzdW1lcicsICRhY2NvdW50OiAnNjY2NjYnIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICdkZWZhdWx0JzogeyByZWdpb246ICdldS1ibGEtNScgfSxcbiAgICAgICAgICAncHJvZmlsZSBhc3N1bWVyJzogeyByZWdpb246ICd1cy1lYXN0LTInIH0sXG4gICAgICAgICAgJ3Byb2ZpbGUgbWZhLXJvbGUnOiB7XG4gICAgICAgICAgICByb2xlX2FybjogJ2Fybjphd3M6aWFtOjo2NjY2Njpyb2xlL0Fzc3VtYWJsZScsXG4gICAgICAgICAgICBzb3VyY2VfcHJvZmlsZTogJ2Fzc3VtZXInLFxuICAgICAgICAgICAgbWZhX3NlcmlhbDogJ2Fybjphd3M6aWFtOjphY2NvdW50Om1mYS91c2VyJyxcbiAgICAgICAgICAgICRhY2NvdW50OiAnNjY2NjYnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgcHJvdmlkZXJGcm9tUHJvZmlsZSgnbWZhLXJvbGUnKTtcblxuICAgICAgY29uc3QgcHJvbXB0bHlNb2NrQ2FsbHMgPSAocHJvbXB0bHkucHJvbXB0IGFzIGplc3QuTW9jaykubW9jay5jYWxscy5sZW5ndGg7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGNvbnN0IHNkayA9IChhd2FpdCBwcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnYodW5pcSgnNjY2NjYnKSksIE1vZGUuRm9yUmVhZGluZykpLnNkaztcbiAgICAgIGV4cGVjdCgoYXdhaXQgc2RrLmN1cnJlbnRBY2NvdW50KCkpLmFjY291bnRJZCkudG9FcXVhbCh1bmlxKCc2NjY2NicpKTtcbiAgICAgIGV4cGVjdChmYWtlU3RzLmFzc3VtZWRSb2xlc1swXSkudG9FcXVhbChleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIHJvbGVBcm46ICdhcm46YXdzOmlhbTo6NjY2NjY6cm9sZS9Bc3N1bWFibGUnLFxuICAgICAgICBzZXJpYWxOdW1iZXI6ICdhcm46YXdzOmlhbTo6YWNjb3VudDptZmEvdXNlcicsXG4gICAgICAgIHRva2VuQ29kZTogJzEyMzQnLFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBNb2NrIHJlc3BvbnNlIHdhcyBzZXQgdG8gZmFpbCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgY2FsbCBTVFNcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgTUZBIG1vY2sgd2FzIGNhbGxlZCBkdXJpbmcgdGhpcyB0ZXN0XG4gICAgICBleHBlY3QoKHByb21wdGx5LnByb21wdCBhcyBqZXN0Lk1vY2spLm1vY2suY2FsbHMubGVuZ3RoKS50b0JlKHByb21wdGx5TW9ja0NhbGxzICsgMSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIEZvciBEZWZhdWx0U3ludGhlc2lzIHdlIHdpbGwgZG8gYW4gYXNzdW1lLXJvbGUgYWZ0ZXIgaGF2aW5nIGdvdHRlbiBiYXNlIGNyZWRlbnRpYWxzXG4gIGRlc2NyaWJlKCd3aGVuIENESyBBc3N1bWVSb2xlcycsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIC8vIEFsbCB0aGVzZSB0ZXN0cyBzaGFyZSB0aGF0ICdhcm46YXdzOnJvbGUnIGlzIGEgcm9sZSBpbnRvIGFjY291bnQgODg4ODggd2hpY2ggY2FuIGJlIGFzc3VtZWQgZnJvbSAxMTExMVxuICAgICAgZmFrZVN0cy5yZWdpc3RlclJvbGUodW5pcSgnODg4ODgnKSwgJ2Fybjphd3M6cm9sZScsIHsgYWxsb3dlZEFjY291bnRzOiBbdW5pcSgnMTExMTEnKV0gfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdlcnJvciB3ZSBnZXQgZnJvbSBhc3N1bWluZyBhIHJvbGUgaXMgdXNlZnVsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIHByZXBhcmVDcmVkcyh7XG4gICAgICAgIGZha2VTdHMsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIGRlZmF1bHQ6IHsgYXdzX2FjY2Vzc19rZXlfaWQ6ICdmb28nIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgcHJvdmlkZXJGcm9tUHJvZmlsZSh1bmRlZmluZWQpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBwcm9taXNlID0gcHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoZW52KHVuaXEoJzg4ODg4JykpLCBNb2RlLkZvclJlYWRpbmcsIHtcbiAgICAgICAgYXNzdW1lUm9sZUFybjogJ2RvZXNub3RleGlzdC5yb2xlLmFybicsXG4gICAgICB9KTtcblxuICAgICAgLy8gVEhFTiAtIGVycm9yIG1lc3NhZ2UgY29udGFpbnMgYm90aCBhIGhlbHBmdWwgaGludCBhbmQgdGhlIHVuZGVybHlpbmcgQXNzdW1lUm9sZSBtZXNzYWdlXG4gICAgICBhd2FpdCBleHBlY3QocHJvbWlzZSkucmVqZWN0cy50b1Rocm93KCcocmUpLWJvb3RzdHJhcCB0aGUgZW52aXJvbm1lbnQnKTtcbiAgICAgIGF3YWl0IGV4cGVjdChwcm9taXNlKS5yZWplY3RzLnRvVGhyb3coJ2RvZXNub3RleGlzdC5yb2xlLmFybicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnYXNzdW1pbmcgYSByb2xlIHNhbml0aXplcyB0aGUgdXNlcm5hbWUgaW50byB0aGUgc2Vzc2lvbiBuYW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIHByZXBhcmVDcmVkcyh7XG4gICAgICAgIGZha2VTdHMsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIGRlZmF1bHQ6IHsgYXdzX2FjY2Vzc19rZXlfaWQ6ICdmb28nLCAkYWNjb3VudDogJzExMTExJyB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdpdGhNb2NrZWQob3MsICd1c2VySW5mbycsIGFzeW5jICh1c2VySW5mbykgPT4ge1xuICAgICAgICB1c2VySW5mby5tb2NrUmV0dXJuVmFsdWUoeyB1c2VybmFtZTogJ3Nrw6VsJywgdWlkOiAxLCBnaWQ6IDEsIGhvbWVkaXI6ICcvaGVyZScsIHNoZWxsOiAnL2Jpbi9zaCcgfSk7XG5cbiAgICAgICAgLy8gV0hFTlxuICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUodW5kZWZpbmVkKTtcblxuICAgICAgICBjb25zdCBzZGsgPSAoYXdhaXQgcHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoZW52KHVuaXEoJzg4ODg4JykpLCBNb2RlLkZvclJlYWRpbmcsIHsgYXNzdW1lUm9sZUFybjogJ2Fybjphd3M6cm9sZScgfSkpLnNkayBhcyBTREs7XG4gICAgICAgIGF3YWl0IHNkay5jdXJyZW50QWNjb3VudCgpO1xuXG4gICAgICAgIC8vIFRIRU5cbiAgICAgICAgZXhwZWN0KGZha2VTdHMuYXNzdW1lZFJvbGVzWzBdKS50b0VxdWFsKGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICByb2xlU2Vzc2lvbk5hbWU6ICdhd3MtY2RrLXNrQGwnLFxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2V2ZW4gaWYgY3VycmVudCBjcmVkZW50aWFscyBhcmUgZm9yIHRoZSB3cm9uZyBhY2NvdW50LCB3ZSB3aWxsIHN0aWxsIHVzZSB0aGVtIHRvIEFzc3VtZVJvbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgcHJlcGFyZUNyZWRzKHtcbiAgICAgICAgZmFrZVN0cyxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgZGVmYXVsdDogeyBhd3NfYWNjZXNzX2tleV9pZDogJ2ZvbycsICRhY2NvdW50OiAnMTExMTEnIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgcHJvdmlkZXJGcm9tUHJvZmlsZSh1bmRlZmluZWQpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBjb25zdCBzZGsgPSAoYXdhaXQgcHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoZW52KHVuaXEoJzg4ODg4JykpLCBNb2RlLkZvclJlYWRpbmcsIHsgYXNzdW1lUm9sZUFybjogJ2Fybjphd3M6cm9sZScgfSkpLnNkayBhcyBTREs7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdCgoYXdhaXQgc2RrLmN1cnJlbnRBY2NvdW50KCkpLmFjY291bnRJZCkudG9FcXVhbCh1bmlxKCc4ODg4OCcpKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2lmIEFzc3VtZVJvbGUgZmFpbHMgYnV0IGN1cnJlbnQgY3JlZGVudGlhbHMgYXJlIGZvciB0aGUgcmlnaHQgYWNjb3VudCwgd2Ugd2lsbCBzdGlsbCB1c2UgdGhlbScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEdJVkVOXG4gICAgICBwcmVwYXJlQ3JlZHMoe1xuICAgICAgICBmYWtlU3RzLFxuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICBkZWZhdWx0OiB7IGF3c19hY2Nlc3Nfa2V5X2lkOiAnZm9vJywgJGFjY291bnQ6ICc4ODg4OCcgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBwcm92aWRlckZyb21Qcm9maWxlKHVuZGVmaW5lZCk7XG5cbiAgICAgIC8vIFdIRU4gLSBhc3N1bWVSb2xlIGZhaWxzIGJlY2F1c2UgdGhlIHJvbGUgY2FuIG9ubHkgYmUgYXNzdW1lZCBmcm9tIGFjY291bnQgMTExMTFcbiAgICAgIGNvbnN0IHNkayA9IChhd2FpdCBwcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnYodW5pcSgnODg4ODgnKSksIE1vZGUuRm9yUmVhZGluZywgeyBhc3N1bWVSb2xlQXJuOiAnYXJuOmF3czpyb2xlJyB9KSkuc2RrIGFzIFNESztcblxuICAgICAgLy8gVEhFTlxuICAgICAgZXhwZWN0KChhd2FpdCBzZGsuY3VycmVudEFjY291bnQoKSkuYWNjb3VudElkKS50b0VxdWFsKHVuaXEoJzg4ODg4JykpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGx1Z2lucycsICgpID0+IHtcbiAgICB0ZXN0KCdkb2VzIG5vdCB1c2UgcGx1Z2lucyBpZiBjdXJyZW50IGNyZWRlbnRpYWxzIGFyZSBmb3IgZXhwZWN0ZWQgYWNjb3VudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHByZXBhcmVDcmVkcyh7XG4gICAgICAgIGZha2VTdHMsXG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIGRlZmF1bHQ6IHsgYXdzX2FjY2Vzc19rZXlfaWQ6ICdmb28nLCAkYWNjb3VudDogJzExMTExJyB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUodW5kZWZpbmVkKTtcbiAgICAgIGF3YWl0IHByb3ZpZGVyLmZvckVudmlyb25tZW50KGVudih1bmlxKCcxMTExMScpKSwgTW9kZS5Gb3JSZWFkaW5nKTtcbiAgICAgIGV4cGVjdChwbHVnaW5RdWVyaWVkKS50b0VxdWFsKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3VzZXMgcGx1Z2luIGZvciBhY2NvdW50IDk5OTk5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBwcm92aWRlckZyb21Qcm9maWxlKHVuZGVmaW5lZCk7XG4gICAgICBhd2FpdCBwcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnYodW5pcSgnOTk5OTknKSksIE1vZGUuRm9yUmVhZGluZyk7XG4gICAgICBleHBlY3QocGx1Z2luUXVlcmllZCkudG9FcXVhbCh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2NhbiBhc3N1bWUgcm9sZSB3aXRoIGNyZWRlbnRpYWxzIGZyb20gcGx1Z2luJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZmFrZVN0cy5yZWdpc3RlclJvbGUodW5pcSgnOTk5OTknKSwgJ2Fybjphd3M6aWFtOjo5OTk5OTpyb2xlL0Fzc3VtYWJsZScpO1xuXG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUodW5kZWZpbmVkKTtcbiAgICAgIGF3YWl0IHByb3ZpZGVyLmZvckVudmlyb25tZW50KGVudih1bmlxKCc5OTk5OScpKSwgTW9kZS5Gb3JSZWFkaW5nLCB7XG4gICAgICAgIGFzc3VtZVJvbGVBcm46ICdhcm46YXdzOmlhbTo6OTk5OTk6cm9sZS9Bc3N1bWFibGUnLFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChmYWtlU3RzLmFzc3VtZWRSb2xlc1swXSkudG9FcXVhbChleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIHJvbGVBcm46ICdhcm46YXdzOmlhbTo6OTk5OTk6cm9sZS9Bc3N1bWFibGUnLFxuICAgICAgfSkpO1xuICAgICAgZXhwZWN0KHBsdWdpblF1ZXJpZWQpLnRvRXF1YWwodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdldmVuIGlmIEFzc3VtZVJvbGUgZmFpbHMgYnV0IGN1cnJlbnQgY3JlZGVudGlhbHMgYXJlIGZyb20gYSBwbHVnaW4sIHdlIHdpbGwgc3RpbGwgdXNlIHRoZW0nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHNkayA9IChhd2FpdCBwcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnYodW5pcSgnOTk5OTknKSksIE1vZGUuRm9yUmVhZGluZywgeyBhc3N1bWVSb2xlQXJuOiAnZG9lczpub3Q6ZXhpc3QnIH0pKS5zZGs7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdCgoYXdhaXQgc2RrLmN1cnJlbnRBY2NvdW50KCkpLmFjY291bnRJZCkudG9FcXVhbCh1bmlxKCc5OTk5OScpKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3BsdWdpbnMgYXJlIHN0aWxsIHF1ZXJpZWQgZXZlbiBpZiBjdXJyZW50IGNyZWRlbnRpYWxzIGFyZSBleHBpcmVkIChvciBvdGhlcndpc2UgaW52YWxpZCknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBHSVZFTlxuICAgICAgcHJvY2Vzcy5lbnYuQVdTX0FDQ0VTU19LRVlfSUQgPSBgJHt1aWR9YWtpZGA7XG4gICAgICBwcm9jZXNzLmVudi5BV1NfU0VDUkVUX0FDQ0VTU19LRVkgPSAnc2Vrcml0JztcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgcHJvdmlkZXJGcm9tUHJvZmlsZSh1bmRlZmluZWQpO1xuXG4gICAgICAvLyBXSEVOXG4gICAgICBhd2FpdCBwcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnYodW5pcSgnOTk5OTknKSksIE1vZGUuRm9yUmVhZGluZyk7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdChwbHVnaW5RdWVyaWVkKS50b0VxdWFsKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnc3VwcG9ydCBmb3IgY3JlZGVudGlhbF9zb3VyY2UnLCAoKSA9PiB7XG4gICAgdGVzdCgnY2FuIGFzc3VtZSByb2xlIHdpdGggZWNzIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIHdpdGhNb2NrZWQoQVdTLkVDU0NyZWRlbnRpYWxzLnByb3RvdHlwZSwgJ25lZWRzUmVmcmVzaCcsIGFzeW5jIChuZWVkc1JlZnJlc2gpID0+IHtcbiAgICAgICAgLy8gR0lWRU5cbiAgICAgICAgcHJlcGFyZUNyZWRzKHtcbiAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICdwcm9maWxlIGVjcyc6IHsgcm9sZV9hcm46ICdhcm46YXdzOmlhbTo6MTIzNTY3ODkwMTI6cm9sZS9Bc3N1bWFibGUnLCBjcmVkZW50aWFsX3NvdXJjZTogJ0Vjc0NvbnRhaW5lcicsICRhY2NvdW50OiAnMjIyMjInIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgcHJvdmlkZXJGcm9tUHJvZmlsZSgnZWNzJyk7XG5cbiAgICAgICAgLy8gV0hFTlxuICAgICAgICBhd2FpdCBwcm92aWRlci5kZWZhdWx0QWNjb3VudCgpO1xuXG4gICAgICAgIC8vIFRIRU5cbiAgICAgICAgZXhwZWN0KG5lZWRzUmVmcmVzaCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHRlc3QoJ2NhbiBhc3N1bWUgcm9sZSB3aXRoIGVjMiBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiB3aXRoTW9ja2VkKEFXUy5FQzJNZXRhZGF0YUNyZWRlbnRpYWxzLnByb3RvdHlwZSwgJ25lZWRzUmVmcmVzaCcsIGFzeW5jIChuZWVkc1JlZnJlc2gpID0+IHtcbiAgICAgICAgLy8gR0lWRU5cbiAgICAgICAgcHJlcGFyZUNyZWRzKHtcbiAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICdwcm9maWxlIGVjcyc6IHsgcm9sZV9hcm46ICdhcm46YXdzOmlhbTo6MTIzNTY3ODkwMTI6cm9sZS9Bc3N1bWFibGUnLCBjcmVkZW50aWFsX3NvdXJjZTogJ0VjMkluc3RhbmNlTWV0YWRhdGEnLCAkYWNjb3VudDogJzIyMjIyJyB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUoJ2VjcycpO1xuXG4gICAgICAgIC8vIFdIRU5cbiAgICAgICAgYXdhaXQgcHJvdmlkZXIuZGVmYXVsdEFjY291bnQoKTtcblxuICAgICAgICAvLyBUSEVOXG4gICAgICAgIGV4cGVjdChuZWVkc1JlZnJlc2gpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIHRlc3QoJ2NhbiBhc3N1bWUgcm9sZSB3aXRoIGVudiBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiB3aXRoTW9ja2VkKEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzLnByb3RvdHlwZSwgJ25lZWRzUmVmcmVzaCcsIGFzeW5jIChuZWVkc1JlZnJlc2gpID0+IHtcbiAgICAgICAgLy8gR0lWRU5cbiAgICAgICAgcHJlcGFyZUNyZWRzKHtcbiAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICdwcm9maWxlIGVjcyc6IHsgcm9sZV9hcm46ICdhcm46YXdzOmlhbTo6MTIzNTY3ODkwMTI6cm9sZS9Bc3N1bWFibGUnLCBjcmVkZW50aWFsX3NvdXJjZTogJ0Vudmlyb25tZW50JywgJGFjY291bnQ6ICcyMjIyMicgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBwcm92aWRlckZyb21Qcm9maWxlKCdlY3MnKTtcblxuICAgICAgICAvLyBXSEVOXG4gICAgICAgIGF3YWl0IHByb3ZpZGVyLmRlZmF1bHRBY2NvdW50KCk7XG5cbiAgICAgICAgLy8gVEhFTlxuICAgICAgICBleHBlY3QobmVlZHNSZWZyZXNoKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2Fzc3VtZSBmYWlscyB3aXRoIHVuc3VwcG9ydGVkIGNyZWRlbnRpYWxfc291cmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gR0lWRU5cbiAgICAgIHByZXBhcmVDcmVkcyh7XG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICdwcm9maWxlIGVjcyc6IHsgcm9sZV9hcm46ICdhcm46YXdzOmlhbTo6MTIzNTY3ODkwMTI6cm9sZS9Bc3N1bWFibGUnLCBjcmVkZW50aWFsX3NvdXJjZTogJ3Vuc3VwcG9ydGVkJywgJGFjY291bnQ6ICcyMjIyMicgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBwcm92aWRlckZyb21Qcm9maWxlKCdlY3MnKTtcblxuICAgICAgLy8gV0hFTlxuICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHByb3ZpZGVyLmRlZmF1bHRBY2NvdW50KCk7XG5cbiAgICAgIC8vIFRIRU5cbiAgICAgIGV4cGVjdChhY2NvdW50Py5hY2NvdW50SWQpLnRvRXF1YWwodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgnZGVmYXVsdEFjY291bnQgcmV0dXJucyB1bmRlZmluZWQgaWYgU1RTIGNhbGwgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gR0lWRU5cbiAgICBwcm9jZXNzLmVudi5BV1NfQUNDRVNTX0tFWV9JRCA9IGAke3VpZH1ha2lkYDtcbiAgICBwcm9jZXNzLmVudi5BV1NfU0VDUkVUX0FDQ0VTU19LRVkgPSAnc2Vrcml0JztcblxuICAgIC8vIFdIRU5cbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHByb3ZpZGVyRnJvbVByb2ZpbGUodW5kZWZpbmVkKTtcblxuICAgIC8vIFRIRU5cbiAgICBhd2FpdCBleHBlY3QocHJvdmlkZXIuZGVmYXVsdEFjY291bnQoKSkucmVzb2x2ZXMudG9CZSh1bmRlZmluZWQpO1xuICB9KTtcbn0pO1xuXG50ZXN0KCdldmVuIHdoZW4gdXNpbmcgYSBwcm9maWxlIHRvIGFzc3VtZSBhbm90aGVyIHByb2ZpbGUsIFNUUyBjYWxscyBnb2VzIHRocm91Z2ggdGhlIHByb3h5JywgYXN5bmMgKCkgPT4ge1xuICBwcmVwYXJlQ3JlZHMoe1xuICAgIGNyZWRlbnRpYWxzOiB7XG4gICAgICBhc3N1bWVyOiB7IGF3c19hY2Nlc3Nfa2V5X2lkOiAnYXNzdW1lcicgfSxcbiAgICB9LFxuICAgIGNvbmZpZzoge1xuICAgICAgJ2RlZmF1bHQnOiB7IHJlZ2lvbjogJ2V1LWJsYS01JyB9LFxuICAgICAgJ3Byb2ZpbGUgYXNzdW1hYmxlJzogeyByb2xlX2FybjogJ2Fybjphd3M6aWFtOjo2NjY2Njpyb2xlL0Fzc3VtYWJsZScsIHNvdXJjZV9wcm9maWxlOiAnYXNzdW1lcicsICRhY2NvdW50OiAnNjY2NjYnIH0sXG4gICAgICAncHJvZmlsZSBhc3N1bWVyJzogeyByZWdpb246ICd1cy1lYXN0LTInIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgLy8gTWVzc3kgbW9ja2luZ1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIGplc3QubW9jaygncHJveHktYWdlbnQnLCAoKSA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICBjbGFzcyBGYWtlQWdlbnQgZXh0ZW5kcyByZXF1aXJlKCdodHRwcycpLkFnZW50IHtcbiAgICAgIHB1YmxpYyBhZGRSZXF1ZXN0KF86IGFueSwgX186IGFueSkge1xuICAgICAgICAvLyBGSVhNRTogdGhpcyBlcnJvciB0YWtlcyA2IHNlY29uZHMgdG8gYmUgY29tcGxldGVseSBoYW5kbGVkLiBJdFxuICAgICAgICAvLyBtaWdodCBiZSByZXRyaWVzIGluIHRoZSBTREsgc29tZXdoZXJlLCBvciBzb21ldGhpbmcgYWJvdXQgdGhlIE5vZGVcbiAgICAgICAgLy8gZXZlbnQgbG9vcC4gSSd2ZSBzcGVudCBhbiBob3VyIHRyeWluZyB0byBmaWd1cmUgaXQgb3V0IGFuZCBJIGNhbid0LFxuICAgICAgICAvLyBhbmQgSSBnYXZlIHVwLiBXZSdsbCBqdXN0IGhhdmUgdG8gbGl2ZSB3aXRoIHRoaXMgdW50aWwgc29tZW9uZSBnZXRzXG4gICAgICAgIC8vIGluc3BpcmVkLlxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQUJPUlRFRCBCWSBURVNUJyk7XG4gICAgICAgIChlcnJvciBhcyBhbnkpLmNvZGUgPSAnUmVxdWVzdEFib3J0ZWRFcnJvcic7XG4gICAgICAgIChlcnJvciBhcyBhbnkpLnJldHJ5YWJsZSA9IGZhbHNlO1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZha2VBZ2VudDtcbiAgfSk7XG5cbiAgLy8gV0hFTlxuICBjb25zdCBwcm92aWRlciA9IGF3YWl0IFNka1Byb3ZpZGVyLndpdGhBd3NDbGlDb21wYXRpYmxlRGVmYXVsdHMoe1xuICAgIC4uLmRlZmF1bHRDcmVkT3B0aW9ucyxcbiAgICBwcm9maWxlOiAnYXNzdW1hYmxlJyxcbiAgICBodHRwT3B0aW9uczoge1xuICAgICAgcHJveHlBZGRyZXNzOiAnaHR0cDovL0RPRVNOVE1BVFRFUi8nLFxuICAgIH0sXG4gIH0pO1xuXG4gIGF3YWl0IHByb3ZpZGVyLmRlZmF1bHRBY2NvdW50KCk7XG5cbiAgLy8gVEhFTiAtLSB0aGUgZmFrZSBwcm94eSBhZ2VudCBnb3QgY2FsbGVkLCB3ZSBkb24ndCBjYXJlIGFib3V0IHRoZSByZXN1bHRcbiAgZXhwZWN0KGNhbGxlZCkudG9FcXVhbCh0cnVlKTtcbn0pO1xuXG4vKipcbiAqIFVzZSBvYmplY3QgaGFja2VyeSB0byBnZXQgdGhlIGNyZWRlbnRpYWxzIG91dCBvZiB0aGUgU0RLIG9iamVjdFxuICovXG5mdW5jdGlvbiBzZGtDb25maWcoc2RrOiBJU0RLKTogQ29uZmlndXJhdGlvbk9wdGlvbnMge1xuICByZXR1cm4gKHNkayBhcyBhbnkpLmNvbmZpZztcbn1cblxuLyoqXG4gKiBGaXh0dXJlIGZvciBTREsgYXV0aCBmb3IgdGhpcyB0ZXN0IHN1aXRlXG4gKlxuICogSGFzIGtub3dsZWRnZSBvZiB0aGUgY2FjaGUgYnVzdGVyLCB3aWxsIHdyaXRlIHByb3BlciBmYWtlIGNvbmZpZyBmaWxlcyBhbmRcbiAqIHJlZ2lzdGVyIHVzZXJzIGFuZCByb2xlcyBpbiBGYWtlU3RzIGF0IHRoZSBzYW1lIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVDcmVkcyhvcHRpb25zOiBQcmVwYXJlQ3JlZHNPcHRpb25zKSB7XG4gIGZ1bmN0aW9uIGNvbnZlcnRTZWN0aW9ucyhzZWN0aW9ucz86IFJlY29yZDxzdHJpbmcsIFByb2ZpbGVVc2VyIHwgUHJvZmlsZVJvbGU+KSB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChjb25zdCBbcHJvZmlsZSwgdXNlcl0gb2YgT2JqZWN0LmVudHJpZXMoc2VjdGlvbnMgPz8ge30pKSB7XG4gICAgICByZXQucHVzaChgWyR7cHJvZmlsZX1dYCk7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGVSb2xlKHVzZXIpKSB7XG4gICAgICAgIHJldC5wdXNoKGByb2xlX2Fybj0ke3VzZXIucm9sZV9hcm59YCk7XG4gICAgICAgIGlmICgnc291cmNlX3Byb2ZpbGUnIGluIHVzZXIpIHtcbiAgICAgICAgICByZXQucHVzaChgc291cmNlX3Byb2ZpbGU9JHt1c2VyLnNvdXJjZV9wcm9maWxlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnY3JlZGVudGlhbF9zb3VyY2UnIGluIHVzZXIpIHtcbiAgICAgICAgICByZXQucHVzaChgY3JlZGVudGlhbF9zb3VyY2U9JHt1c2VyLmNyZWRlbnRpYWxfc291cmNlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyLm1mYV9zZXJpYWwpIHtcbiAgICAgICAgICByZXQucHVzaChgbWZhX3NlcmlhbD0ke3VzZXIubWZhX3NlcmlhbH1gKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmZha2VTdHM/LnJlZ2lzdGVyUm9sZSh1bmlxKHVzZXIuJGFjY291bnQgPz8gJzAwMDAwJyksIHVzZXIucm9sZV9hcm4sIHtcbiAgICAgICAgICAuLi51c2VyLiRmYWtlU3RzT3B0aW9ucyxcbiAgICAgICAgICBhbGxvd2VkQWNjb3VudHM6IHVzZXIuJGZha2VTdHNPcHRpb25zPy5hbGxvd2VkQWNjb3VudHM/Lm1hcCh1bmlxKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodXNlci5hd3NfYWNjZXNzX2tleV9pZCkge1xuICAgICAgICAgIHJldC5wdXNoKGBhd3NfYWNjZXNzX2tleV9pZD0ke3VuaXEodXNlci5hd3NfYWNjZXNzX2tleV9pZCl9YCk7XG4gICAgICAgICAgcmV0LnB1c2goJ2F3c19zZWNyZXRfYWNjZXNzX2tleT1zZWNyZXQnKTtcbiAgICAgICAgICBvcHRpb25zLmZha2VTdHM/LnJlZ2lzdGVyVXNlcih1bmlxKHVzZXIuJGFjY291bnQgPz8gJzAwMDAwJyksIHVuaXEodXNlci5hd3NfYWNjZXNzX2tleV9pZCksIHVzZXIuJGZha2VTdHNPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodXNlci5yZWdpb24pIHtcbiAgICAgICAgcmV0LnB1c2goYHJlZ2lvbj0ke3VzZXIucmVnaW9ufWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgYm9ja2ZzKHtcbiAgICAnL2hvbWUvbWUvLmJ4dC9jcmVkZW50aWFscyc6IGNvbnZlcnRTZWN0aW9ucyhvcHRpb25zLmNyZWRlbnRpYWxzKSxcbiAgICAnL2hvbWUvbWUvLmJ4dC9jb25maWcnOiBjb252ZXJ0U2VjdGlvbnMob3B0aW9ucy5jb25maWcpLFxuICB9KTtcblxuICAvLyBTZXQgZW52aXJvbm1lbnQgdmFyaWFibGVzIHRoYXQgd2Ugd2FudFxuICBwcm9jZXNzLmVudi5BV1NfQ09ORklHX0ZJTEUgPSBib2NrZnMucGF0aCgnL2hvbWUvbWUvLmJ4dC9jb25maWcnKTtcbiAgcHJvY2Vzcy5lbnYuQVdTX1NIQVJFRF9DUkVERU5USUFMU19GSUxFID0gYm9ja2ZzLnBhdGgoJy9ob21lL21lLy5ieHQvY3JlZGVudGlhbHMnKTtcbn1cblxuaW50ZXJmYWNlIFByZXBhcmVDcmVkc09wdGlvbnMge1xuICAvKipcbiAgICogV3JpdGUgdGhlIGF3cy9jcmVkZW50aWFscyBmaWxlXG4gICAqL1xuICByZWFkb25seSBjcmVkZW50aWFscz86IFJlY29yZDxzdHJpbmcsIFByb2ZpbGVVc2VyIHwgUHJvZmlsZVJvbGU+O1xuXG4gIC8qKlxuICAgKiBXcml0ZSB0aGUgYXdzL2NvbmZpZyBmaWxlXG4gICAqL1xuICByZWFkb25seSBjb25maWc/OiBSZWNvcmQ8c3RyaW5nLCBQcm9maWxlVXNlciB8IFByb2ZpbGVSb2xlPjtcblxuICAvKipcbiAgICogSWYgZ2l2ZW4sIGFkZCB1c2VycyB0byBGYWtlU1RTXG4gICAqL1xuICByZWFkb25seSBmYWtlU3RzPzogRmFrZVN0cztcbn1cblxuaW50ZXJmYWNlIFByb2ZpbGVVc2VyIHtcbiAgcmVhZG9ubHkgYXdzX2FjY2Vzc19rZXlfaWQ/OiBzdHJpbmc7XG4gIHJlYWRvbmx5ICRhY2NvdW50Pzogc3RyaW5nO1xuICByZWFkb25seSByZWdpb24/OiBzdHJpbmc7XG4gIHJlYWRvbmx5ICRmYWtlU3RzT3B0aW9ucz86IFJlZ2lzdGVyVXNlck9wdGlvbnM7XG59XG5cbnR5cGUgUHJvZmlsZVJvbGUgPSB7XG4gIHJlYWRvbmx5IHJvbGVfYXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG1mYV9zZXJpYWw/OiBzdHJpbmc7XG4gIHJlYWRvbmx5ICRhY2NvdW50OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlZ2lvbj86IHN0cmluZztcbiAgcmVhZG9ubHkgJGZha2VTdHNPcHRpb25zPzogUmVnaXN0ZXJSb2xlT3B0aW9ucztcbn0gJiAoeyByZWFkb25seSBzb3VyY2VfcHJvZmlsZTogc3RyaW5nIH0gfCB7IHJlYWRvbmx5IGNyZWRlbnRpYWxfc291cmNlOiBzdHJpbmcgfSk7XG5cbmZ1bmN0aW9uIGlzUHJvZmlsZVJvbGUoeDogUHJvZmlsZVVzZXIgfCBQcm9maWxlUm9sZSk6IHggaXMgUHJvZmlsZVJvbGUge1xuICByZXR1cm4gJ3JvbGVfYXJuJyBpbiB4O1xufVxuXG5mdW5jdGlvbiBwcm92aWRlckZyb21Qcm9maWxlKHByb2ZpbGU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICByZXR1cm4gU2RrUHJvdmlkZXIud2l0aEF3c0NsaUNvbXBhdGlibGVEZWZhdWx0cyh7IC4uLmRlZmF1bHRDcmVkT3B0aW9ucywgcHJvZmlsZSB9KTtcbn1cbiJdfQ==